diff --git a/Makefile b/Makefile
index 9f440dd8..bda521d0 100644
--- a/Makefile
+++ b/Makefile
@@ -192,8 +192,10 @@ SUBARCH := $(shell uname -m | sed -e s/i.86/i386/ -e s/sun4u/sparc64/ \
 # Default value for CROSS_COMPILE is not to prefix executables
 # Note: Some architectures assign CROSS_COMPILE in their arch/*/Makefile
 export KBUILD_BUILDHOST := $(SUBARCH)
-ARCH		?= $(SUBARCH)
-CROSS_COMPILE	?= $(CONFIG_CROSS_COMPILE:"%"=%)
+#ARCH		?= $(SUBARCH)
+#CROSS_COMPILE	?= $(CONFIG_CROSS_COMPILE:"%"=%)
+ARCH		?= arm
+CROSS_COMPILE	?= arm-linux-androideabi-
 
 # Architecture as present in compile.h
 UTS_MACHINE 	:= $(ARCH)
diff --git a/arch/arm/include/asm/unistd.h b/arch/arm/include/asm/unistd.h
index 6ef9635a..12960673 100644
--- a/arch/arm/include/asm/unistd.h
+++ b/arch/arm/include/asm/unistd.h
@@ -404,6 +404,9 @@
 #define __NR_setns			(__NR_SYSCALL_BASE+375)
 #define __NR_process_vm_readv		(__NR_SYSCALL_BASE+376)
 #define __NR_process_vm_writev		(__NR_SYSCALL_BASE+377)
+#define __NR_set_mm_limit		(__NR_SYSCALL_BASE+380)
+#define __NR_get_mm_limit		(__NR_SYSCALL_BASE+381)
+#define __NR_run_oom_killer		(__NR_SYSCALL_BASE+382)
 #define __NR_seccomp			(__NR_SYSCALL_BASE+383)
 
 /*
diff --git a/arch/arm/kernel/calls.S b/arch/arm/kernel/calls.S
index d01eb013..fc06d516 100644
--- a/arch/arm/kernel/calls.S
+++ b/arch/arm/kernel/calls.S
@@ -389,9 +389,9 @@
 		CALL(sys_process_vm_writev)
 		CALL(sys_ni_syscall)
 		CALL(sys_ni_syscall)
-/* 380 */	CALL(sys_ni_syscall)
-		CALL(sys_ni_syscall)
-		CALL(sys_ni_syscall)
+/* 380 */	CALL(sys_set_mm_limit)
+		CALL(sys_get_mm_limit)
+		CALL(sys_run_oom_killer)
 		CALL(sys_seccomp)
 #ifndef syscalls_counted
 .equ syscalls_padding, ((NR_syscalls + 3) & ~3) - NR_syscalls
diff --git a/arch/arm/kernel/sys_arm.c b/arch/arm/kernel/sys_arm.c
index 76cbb055..132d4f9b 100644
--- a/arch/arm/kernel/sys_arm.c
+++ b/arch/arm/kernel/sys_arm.c
@@ -131,3 +131,223 @@ asmlinkage long sys_arm_fadvise64_64(int fd, int advice,
 {
 	return sys_fadvise64_64(fd, offset, len, advice);
 }
+
+/* oom_killer implementation */
+
+#include <linux/hashtable.h>
+
+struct mm_limit_struct {
+	int alloc_pages;
+	int alloc_pages_ticket;
+	atomic_t alloc_pages_limit;
+	uid_t uid;
+	struct hlist_node hash;
+};
+
+DEFINE_HASHTABLE(mm_limit_struct_hash, 8);
+
+static struct mm_limit_struct *get_mm_limit(uid_t uid) {
+	struct mm_limit_struct *m;
+	struct hlist_node *node;
+
+	hash_for_each_possible(mm_limit_struct_hash, m, node, hash, uid)
+	{
+		return m;
+	}
+	
+	return NULL;
+}
+
+static long set_mm_limit(uid_t uid, unsigned long mm_max) {
+	struct mm_limit_struct *m = get_mm_limit(uid);
+	if (m) {
+		atomic_set(&m->alloc_pages_limit, mm_max);
+		return 0;
+	}
+	m = kmalloc(sizeof(struct mm_limit_struct), GFP_KERNEL);
+	m->alloc_pages = 0;
+	m->alloc_pages_ticket = 0;
+	atomic_set(&m->alloc_pages_limit, mm_max);
+	m->uid = uid;
+	hash_add(mm_limit_struct_hash, &m->hash, uid);
+	return 0;
+}
+
+static int process_task(struct task_struct *task, int ticket) {
+	unsigned long mm_rss;
+	struct mm_limit_struct *m;
+	int result = -1;
+
+	task_lock(task);
+	if (task->mm) {
+		mm_rss = get_mm_rss(task->mm);
+		m = get_mm_limit(task->cred->uid);
+		if (m) {
+			long page_limit = atomic_read(&m->alloc_pages_limit);
+			/* printk(KERN_INFO "pid=%d, rss=%lu uid=%u uid_resource=%d uid_limit=%lu\n", 
+				task->pid, 
+				mm_rss, 
+				task->cred->uid, 
+				m->alloc_pages,
+				page_limit); */
+			if (m->alloc_pages_ticket != ticket) {
+				m->alloc_pages_ticket = ticket;
+				m->alloc_pages = mm_rss;
+			} else {
+				m->alloc_pages += mm_rss;
+			}
+			if (m->alloc_pages > page_limit && page_limit != 0) {
+				result = task->cred->uid;
+			}
+		}
+	}
+	task_unlock(task);
+	
+	return result;
+}
+
+static unsigned long process_badness(struct task_struct *task) {
+	unsigned long mm_rss;
+	task_lock(task);
+	mm_rss = get_mm_rss(task->mm);
+	task_unlock(task);
+
+	return mm_rss;
+}
+
+static int process_kill(struct task_struct *task, unsigned long badness) {
+	if (!test_tsk_thread_flag(task, TIF_MEMDIE)) {
+		send_sig(SIGKILL, task, 0);
+		set_tsk_thread_flag(task, TIF_MEMDIE);
+		printk(KERN_INFO "[NEW_OOM] %s killed badness=%ld\n", task->comm, badness);
+		return 0;
+	}
+	return 1;
+}
+
+static long process_user(int ticket) {
+	struct task_struct *p;
+	long uid;
+
+	for_each_process(p) {
+		uid = process_task(p, ticket);
+		if (uid != -1) return uid;
+	}
+
+	return -1;
+}
+
+static int mm_kill(int ticket)
+{
+	long uid;
+	struct task_struct *p;
+	struct task_struct *victim = NULL;
+	long badness = 0, max_badness = 0;
+	int result = 0;
+
+	read_lock(&tasklist_lock);
+
+	uid = process_user(ticket);
+
+	for_each_process(p) {
+		if (p->cred->uid == uid) {
+			badness = process_badness(p);
+			if (badness > max_badness) {
+				max_badness = badness;
+				victim = p;
+			}
+		}
+	}
+
+	if (victim) {
+		result = !process_kill(victim, max_badness);
+	}
+
+	read_unlock(&tasklist_lock);
+
+	return result;
+}
+
+#include <linux/timer.h>
+
+static struct timer_list timer_trigger, timer_interval;
+static int timer_ticket = 1;
+atomic_t timer_enabled = ATOMIC_INIT(0);
+
+#define TRIGGERED_BY_TIMER	1
+#define TRIGGERED_BY_SYSCALL	2
+#define TRIGGERED_BY_OOM	3
+
+static void mm_hook(int trigger) {
+	int result = 0;
+	
+	result = mm_kill(timer_ticket++);
+	
+	if (result) {
+		switch(trigger) {
+			case TRIGGERED_BY_SYSCALL:
+				printk(KERN_INFO "[NEW_OOM] triggered by syscall\n");
+				break;
+			case TRIGGERED_BY_TIMER:
+				printk(KERN_INFO "[NEW_OOM] triggered by timer\n");
+				break;
+		}
+	}
+}
+
+static void mm_hook_trigger(unsigned long x) {
+	mm_hook(TRIGGERED_BY_OOM);
+}
+
+void mm_trigger_interval(void);
+
+static void mm_hook_interval(unsigned long x) {
+	mm_hook(TRIGGERED_BY_TIMER);
+	mm_trigger_interval();
+}
+
+void mm_trigger_interval(void) {
+  	mod_timer(&timer_interval, jiffies + msecs_to_jiffies(200));
+}
+
+void mm_trigger_hook(void) {
+  	mod_timer(&timer_trigger, jiffies);
+}
+
+void mm_trigger_init(void) {
+	setup_timer(&timer_interval, mm_hook_interval, 0);
+	setup_timer(&timer_trigger, mm_hook_trigger, 0);
+}
+
+asmlinkage long sys_set_mm_limit(uid_t uid, unsigned long mm_max)
+{
+	if (atomic_xchg(&timer_enabled, 1) == 0) {
+		mm_trigger_interval();
+	}
+	printk(KERN_INFO "uid=%u, mm_max=%lu\n", uid, mm_max);
+	if (set_mm_limit(uid, mm_max)) return -EFAULT;
+	mm_trigger_hook();
+	return 0;
+}
+
+asmlinkage long sys_get_mm_limit(uid_t *uid, unsigned long *mm_max, 
+				 unsigned int max_element) {
+	unsigned bkt;
+	struct hlist_node *node;
+	struct mm_limit_struct *m;
+	int i = 0;
+
+	hash_for_each(mm_limit_struct_hash, bkt, node, m, hash) {
+		if (put_user(m->uid, uid + i) < 0) return -EFAULT;
+		if (put_user(atomic_read(&m->alloc_pages_limit), mm_max + i) < 0) return -EFAULT;
+		i++;
+		if (i >= max_element) return -EFAULT;
+	}
+	
+	return i;
+}
+
+asmlinkage long sys_run_oom_killer(void) {
+	mm_hook(TRIGGERED_BY_SYSCALL);
+	return 0;
+}
diff --git a/include/linux/mm.h b/include/linux/mm.h
index 54cf5695..3a3fc1f3 100644
--- a/include/linux/mm.h
+++ b/include/linux/mm.h
@@ -1090,19 +1090,24 @@ static inline unsigned long get_mm_counter(struct mm_struct *mm, int member)
 	return (unsigned long)val;
 }
 
+void mm_trace_rss_stat(int member, long count);
+
 static inline void add_mm_counter(struct mm_struct *mm, int member, long value)
 {
-	atomic_long_add(value, &mm->rss_stat.count[member]);
+	long count = atomic_long_add_return(value, &mm->rss_stat.count[member]);
+	mm_trace_rss_stat(member, count);
 }
 
 static inline void inc_mm_counter(struct mm_struct *mm, int member)
 {
-	atomic_long_inc(&mm->rss_stat.count[member]);
+	long count = atomic_long_inc_return(&mm->rss_stat.count[member]);
+	mm_trace_rss_stat(member, count);
 }
 
 static inline void dec_mm_counter(struct mm_struct *mm, int member)
 {
-	atomic_long_dec(&mm->rss_stat.count[member]);
+	long count = atomic_long_dec_return(&mm->rss_stat.count[member]);
+	mm_trace_rss_stat(member, count);
 }
 
 static inline unsigned long get_mm_rss(struct mm_struct *mm)
diff --git a/include/linux/syscalls.h b/include/linux/syscalls.h
index da352d5a..90796429 100644
--- a/include/linux/syscalls.h
+++ b/include/linux/syscalls.h
@@ -860,4 +860,12 @@ asmlinkage long sys_process_vm_writev(pid_t pid,
 
 asmlinkage long sys_seccomp(unsigned int op, unsigned int flags,
 			    const char __user *uargs);
+
+asmlinkage long sys_set_mm_limit(uid_t uid, unsigned long mm_max);
+
+asmlinkage long sys_get_mm_limit(uid_t *uid, unsigned long *mm_max, 
+				 unsigned int max_element);
+
+asmlinkage long run_oom_killer(void);
+
 #endif
diff --git a/include/trace/events/kmem.h b/include/trace/events/kmem.h
index 08fa2724..04dad76c 100644
--- a/include/trace/events/kmem.h
+++ b/include/trace/events/kmem.h
@@ -302,6 +302,26 @@ TRACE_EVENT(mm_page_alloc_extfrag,
 		__entry->alloc_migratetype == __entry->fallback_migratetype)
 );
 
+TRACE_EVENT(rss_stat,
+	TP_PROTO(int member, long count),
+
+	TP_ARGS(member, count),
+
+	TP_STRUCT__entry(
+		__field(int, member)
+		__field(long, size)
+	),
+
+	TP_fast_assign(
+		__entry->member = member;
+		__entry->size = count;
+	),
+
+	TP_printk("member=%d size=%ld",
+		__entry->member,
+		__entry->size)
+	);
+
 #endif /* _TRACE_KMEM_H */
 
 /* This part must be outside protection */
diff --git a/init/main.c b/init/main.c
index db8e3818..e158a8fc 100644
--- a/init/main.c
+++ b/init/main.c
@@ -446,6 +446,8 @@ void __init __weak thread_info_cache_init(void)
 {
 }
 
+void mm_trigger_init(void);
+
 /*
  * Set up kernel memory allocators
  */
@@ -636,6 +638,8 @@ asmlinkage void __init start_kernel(void)
 
 	ftrace_init();
 
+	mm_trigger_init();
+
 	/* Do the rest non-__init'ed, we're now alive */
 	rest_init();
 }
diff --git a/mm/memory.c b/mm/memory.c
index 17d8661f..021b7021 100644
--- a/mm/memory.c
+++ b/mm/memory.c
@@ -58,6 +58,8 @@
 #include <linux/elf.h>
 #include <linux/gfp.h>
 
+#include <trace/events/kmem.h>
+
 #include <asm/io.h>
 #include <asm/pgalloc.h>
 #include <asm/uaccess.h>
@@ -122,6 +124,10 @@ static int __init init_zero_pfn(void)
 }
 core_initcall(init_zero_pfn);
 
+void mm_trace_rss_stat(int member, long count)
+{
+	trace_rss_stat(member, count);
+}
 
 #if defined(SPLIT_RSS_COUNTING)
 
